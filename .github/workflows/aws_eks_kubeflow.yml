on: push
name: aws_eks_kubeflow
jobs:
  build:
    name: Orchestration
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v1
    - name: Build
      run: docker build . --file Dockerfile --tag pulumi-k8s-kubeflow:$(date +%s)
    - name: Cluster Lifecycle
      id: deploy
      uses: docker://ramene/actions:alpha
      env:
        PULUMI_CI: up
        PULUMI_ROOT: infra
        AWS_REGION: us-east-1
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}
      with:
        args: up
    - name: Worker Node Group Authorization # FIX: Here we're no longer using our simple action, we're now switching over to using our customized AWS Action container
      id: kubectl
      uses: docker://ramene/actions-kubectl:v0.0.1 # TODO: need to confirm my assumptions here., previously: `ramene/aws/kubectl@master`
      with:
        args: get po --all-namespaces # TODO: eventually support if we're using kustomize, use `-k`
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  kubeflow:
    name: Deploy Kubeflow
    runs-on: ubuntu-latest
    steps:
    - name: CRD
      id: message
      uses: ramene/simple-echo-action@master
      with:
        broadcast: "broadcast message"
        some_var: "some_var value defined in workflow"
    - name: Broadcast time
      run: echo "The time was ${{ steps.message.outputs.time }}"
    - name: Pulumi
      run: echo "Outputs - ${{ steps.message.outputs.foo }}"